// Generated by CoffeeScript 1.12.5
(function() {
  var Commands,
    hasProp = {}.hasOwnProperty;

  require("./test_helper.js");

  extend(global, require("./test_chrome_stubs.js"));

  extend(global, require("../../background_scripts/bg_utils.js"));

  global.Settings = {
    postUpdateHooks: {},
    get: (function() {
      return "";
    }),
    set: function() {}
  };

  Commands = require("../../background_scripts/commands.js").Commands;

  context("Key mappings", setup(function() {
    return this.testKeySequence = function(key, expectedKeyText, expectedKeyLength) {
      var keySequence;
      keySequence = Commands.parseKeySequence(key);
      assert.equal(expectedKeyText, keySequence.join("/"));
      return assert.equal(expectedKeyLength, keySequence.length);
    };
  }), should("lowercase keys correctly", function() {
    this.testKeySequence("a", "a", 1);
    this.testKeySequence("A", "A", 1);
    return this.testKeySequence("ab", "a/b", 2);
  }), should("recognise non-alphabetic keys", function() {
    this.testKeySequence("#", "#", 1);
    this.testKeySequence(".", ".", 1);
    this.testKeySequence("##", "#/#", 2);
    return this.testKeySequence("..", "./.", 2);
  }), should("parse keys with modifiers", function() {
    this.testKeySequence("<c-a>", "<c-a>", 1);
    this.testKeySequence("<c-A>", "<c-A>", 1);
    this.testKeySequence("<C-A>", "<c-A>", 1);
    this.testKeySequence("<c-a><a-b>", "<c-a>/<a-b>", 2);
    this.testKeySequence("<m-a>", "<m-a>", 1);
    return this.testKeySequence("z<m-a>", "z/<m-a>", 2);
  }), should("normalize with modifiers", function() {
    return this.testKeySequence("<m-c-a-A>", "<a-c-m-A>", 1);
  }), should("parse and normalize named keys", function() {
    this.testKeySequence("<space>", "<space>", 1);
    this.testKeySequence("<Space>", "<space>", 1);
    this.testKeySequence("<C-Space>", "<c-space>", 1);
    this.testKeySequence("<f12>", "<f12>", 1);
    return this.testKeySequence("<F12>", "<f12>", 1);
  }), should("handle angle brackets which are part of not modifiers", function() {
    this.testKeySequence("<", "<", 1);
    this.testKeySequence(">", ">", 1);
    this.testKeySequence("<<", "</<", 2);
    this.testKeySequence(">>", ">/>", 2);
    this.testKeySequence("<>", "</>", 2);
    this.testKeySequence("<>", "</>", 2);
    this.testKeySequence("<<space>", "</<space>", 2);
    this.testKeySequence("<C->>", "<c->>", 1);
    return this.testKeySequence("<a>", "</a/>", 3);
  }), should("negative tests", function() {
    this.testKeySequence("<b-a>", "</b/-/a/>", 5);
    return this.testKeySequence("<c-@@>", "</c/-/@/@/>", 6);
  }));

  context("Validate commands and options", should("have either noRepeat or repeatLimit, but not both", function() {
    var command, options, ref, results;
    ref = Commands.availableCommands;
    results = [];
    for (command in ref) {
      if (!hasProp.call(ref, command)) continue;
      options = ref[command];
      results.push(assert.isTrue(!(options.noRepeat && options.repeatLimit)));
    }
    return results;
  }), should("describe each command", function() {
    var command, options, ref, results;
    ref = Commands.availableCommands;
    results = [];
    for (command in ref) {
      if (!hasProp.call(ref, command)) continue;
      options = ref[command];
      results.push(assert.equal('string', typeof options.description));
    }
    return results;
  }), should("define each command in each command group", function() {
    var command, commands, group, ref, results;
    ref = Commands.commandGroups;
    results = [];
    for (group in ref) {
      if (!hasProp.call(ref, group)) continue;
      commands = ref[group];
      results.push((function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = commands.length; i < len; i++) {
          command = commands[i];
          assert.equal('string', typeof command);
          results1.push(assert.isTrue(Commands.availableCommands[command]));
        }
        return results1;
      })());
    }
    return results;
  }), should("have valid commands for each advanced command", function() {
    var command, i, len, ref, results;
    ref = Commands.advancedCommands;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      command = ref[i];
      assert.equal('string', typeof command);
      results.push(assert.isTrue(Commands.availableCommands[command]));
    }
    return results;
  }), should("have valid commands for each default key mapping", function() {
    var command, count, key, ref, results;
    count = Object.keys(Commands.keyToCommandRegistry).length;
    assert.isTrue(0 < count);
    ref = Commands.keyToCommandRegistry;
    results = [];
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      command = ref[key];
      assert.equal('object', typeof command);
      results.push(assert.isTrue(Commands.availableCommands[command.command]));
    }
    return results;
  }));

  context("Validate advanced commands", setup(function() {
    var commands, group;
    return this.allCommands = [].concat.apply([], (function() {
      var ref, results;
      ref = Commands.commandGroups;
      results = [];
      for (group in ref) {
        if (!hasProp.call(ref, group)) continue;
        commands = ref[group];
        results.push(commands);
      }
      return results;
    })());
  }), should("include each advanced command in a command group", function() {
    var command, i, len, ref, results;
    ref = Commands.advancedCommands;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      command = ref[i];
      results.push(assert.isTrue(0 <= this.allCommands.indexOf(command)));
    }
    return results;
  }));

  context("Parse commands", should("omit whitespace", function() {
    return assert.equal(0, BgUtils.parseLines("    \n    \n   ").length);
  }), should("omit comments", function() {
    return assert.equal(0, BgUtils.parseLines(" # comment   \n \" comment   \n   ").length);
  }), should("join lines", function() {
    assert.equal(1, BgUtils.parseLines("a\\\nb").length);
    return assert.equal("ab", BgUtils.parseLines("a\\\nb")[0]);
  }), should("trim lines", function() {
    assert.equal(2, BgUtils.parseLines("  a  \n  b").length);
    assert.equal("a", BgUtils.parseLines("  a  \n  b")[0]);
    return assert.equal("b", BgUtils.parseLines("  a  \n  b")[1]);
  }));

}).call(this);
