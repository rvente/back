// Generated by CoffeeScript 1.12.5
(function() {
  var activateLinkHintsMode, commandCount, commandName, createGeneralHintTests, createLinks, getHintMarkers, getSelection, initializeModeState, inputs, sendKeyboardEvent, sendKeyboardEvents, stubSettings,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.vimiumDomTestsAreRunning = true;

  HUD.init();

  Frame.registerFrameId({
    chromeFrameId: 0
  });

  getSelection = function() {
    return window.getSelection().toString();
  };

  commandName = commandCount = null;

  initializeModeState = function() {
    var normalMode;
    window.focus();
    Mode.reset();
    handlerStack.reset();
    normalMode = installModes();
    normalMode.setPassKeys("p");
    normalMode.setKeyMapping({
      m: {
        options: {},
        command: "m"
      },
      p: {
        options: {},
        command: "p"
      },
      z: {
        p: {
          options: {},
          command: "zp"
        }
      }
    });
    normalMode.setCommandHandler(function(arg) {
      var command, count, ref;
      command = arg.command, count = arg.count;
      return ref = [command.command, count], commandName = ref[0], commandCount = ref[1], ref;
    });
    commandName = commandCount = null;
    return normalMode;
  };

  Settings.isLoaded = true;

  Utils.nextTick = function(func) {
    return func();
  };

  getHintMarkers = function() {
    return Array.prototype.slice.call(document.getElementsByClassName("vimiumHintMarker"), 0);
  };

  stubSettings = function(key, value) {
    return stub(Settings.cache, key, JSON.stringify(value));
  };

  HintCoordinator.sendMessage = function(name, request) {
    if (request == null) {
      request = {};
    }
    if (typeof HintCoordinator[name] === "function") {
      HintCoordinator[name](request);
    }
    return request;
  };

  activateLinkHintsMode = function() {
    HintCoordinator.getHintDescriptors({
      modeIndex: 0
    });
    return HintCoordinator.activateMode({
      hintDescriptors: {},
      modeIndex: 0,
      originatingFrameId: frameId
    });
  };

  createGeneralHintTests = function(isFilteredMode) {
    return context("Link hints", setup(function() {
      var testContent;
      initializeModeState();
      testContent = "<a>test</a>" + "<a>tress</a>";
      document.getElementById("test-div").innerHTML = testContent;
      stubSettings("filterLinkHints", isFilteredMode);
      stubSettings("linkHintCharacters", "ab");
      stubSettings("linkHintNumbers", "12");
      return stub(window, "windowIsFocused", function() {
        return true;
      });
    }), tearDown(function() {
      return document.getElementById("test-div").innerHTML = "";
    }), should("create hints when activated, discard them when deactivated", function() {
      var linkHints;
      linkHints = activateLinkHintsMode();
      assert.isFalse(linkHints.hintMarkerContainingDiv == null);
      linkHints.deactivateMode();
      return assert.isTrue(linkHints.hintMarkerContainingDiv == null);
    }), should("position items correctly", function() {
      var assertStartPosition, hintMarkers, linkHints;
      assertStartPosition = function(element1, element2) {
        assert.equal(element1.getClientRects()[0].left, element2.getClientRects()[0].left);
        return assert.equal(element1.getClientRects()[0].top, element2.getClientRects()[0].top);
      };
      stub(document.body, "style", "static");
      linkHints = activateLinkHintsMode();
      hintMarkers = getHintMarkers();
      assertStartPosition(document.getElementsByTagName("a")[0], hintMarkers[0]);
      assertStartPosition(document.getElementsByTagName("a")[1], hintMarkers[1]);
      linkHints.deactivateMode();
      stub(document.body.style, "position", "relative");
      linkHints = activateLinkHintsMode();
      hintMarkers = getHintMarkers();
      assertStartPosition(document.getElementsByTagName("a")[0], hintMarkers[0]);
      assertStartPosition(document.getElementsByTagName("a")[1], hintMarkers[1]);
      return linkHints.deactivateMode();
    }));
  };

  createGeneralHintTests(false);

  createGeneralHintTests(true);

  context("False positives in link-hint", setup(function() {
    var testContent;
    testContent = '<span class="buttonWrapper">false positive<a>clickable</a></span>' + '<span class="buttonWrapper">clickable</span>';
    document.getElementById("test-div").innerHTML = testContent;
    stubSettings("filterLinkHints", true);
    stubSettings("linkHintNumbers", "12");
    return stub(window, "windowIsFocused", function() {
      return true;
    });
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("handle false positives", function() {
    var hintMarker, hintMarkers, j, len, linkHints, results;
    linkHints = activateLinkHintsMode();
    hintMarkers = getHintMarkers();
    linkHints.deactivateMode();
    assert.equal(2, hintMarkers.length);
    results = [];
    for (j = 0, len = hintMarkers.length; j < len; j++) {
      hintMarker = hintMarkers[j];
      results.push(assert.equal("clickable", hintMarker.linkText));
    }
    return results;
  }));

  context("jsaction matching", setup(function() {
    var testContent;
    stubSettings("filterLinkHints", true);
    testContent = '<p id="test-paragraph">clickable</p>';
    document.getElementById("test-div").innerHTML = testContent;
    return this.element = document.getElementById("test-paragraph");
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("select jsaction elements", function() {
    var hintMarkers, j, len, linkHints, ref, results, text;
    ref = ["click:namespace.actionName", "namespace.actionName"];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      text = ref[j];
      this.element.setAttribute("jsaction", text);
      linkHints = activateLinkHintsMode();
      hintMarkers = getHintMarkers().filter(function(marker) {
        return marker.linkText !== "Frame.";
      });
      linkHints.deactivateMode();
      assert.equal(1, hintMarkers.length);
      assert.equal("clickable", hintMarkers[0].linkText);
      results.push(assert.equal(this.element, hintMarkers[0].localHintDescriptor.element));
    }
    return results;
  }), should("not select inactive jsaction elements", function() {
    var hintMarkers, j, len, linkHints, ref, results, text;
    ref = ["mousedown:namespace.actionName", "click:namespace._", "none", "namespace:_"];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      text = ref[j];
      this.element.setAttribute("jsaction", text);
      linkHints = activateLinkHintsMode();
      hintMarkers = getHintMarkers().filter(function(marker) {
        return marker.linkText !== "Frame.";
      });
      linkHints.deactivateMode();
      results.push(assert.equal(0, hintMarkers.length));
    }
    return results;
  }));

  sendKeyboardEvent = function(key, type, extra) {
    if (type == null) {
      type = "keydown";
    }
    if (extra == null) {
      extra = {};
    }
    return handlerStack.bubbleEvent(type, extend(extra, {
      type: type,
      key: key,
      preventDefault: function() {},
      stopImmediatePropagation: function() {}
    }));
  };

  sendKeyboardEvents = function(keys) {
    var j, key, len, ref, results;
    ref = keys.split("");
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      results.push(sendKeyboardEvent(key));
    }
    return results;
  };

  inputs = [];

  context("Test link hints for focusing input elements correctly", setup(function() {
    var input, inputTypes, j, len, testDiv, type;
    initializeModeState();
    testDiv = document.getElementById("test-div");
    testDiv.innerHTML = "";
    stubSettings("filterLinkHints", false);
    stubSettings("linkHintCharacters", "ab");
    inputTypes = ["button", "checkbox", "date", "datetime", "datetime-local", "email", "file", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"];
    for (j = 0, len = inputTypes.length; j < len; j++) {
      type = inputTypes[j];
      input = document.createElement("input");
      input.type = type;
      testDiv.appendChild(input);
      inputs.push(input);
    }
    input = document.createElement("select");
    testDiv.appendChild(input);
    return inputs.push(input);
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("Focus each input when its hint text is typed", function() {
    var activeListener, char, hint, input, j, k, len, len1, ref, results;
    results = [];
    for (j = 0, len = inputs.length; j < len; j++) {
      input = inputs[j];
      input.scrollIntoView();
      activeListener = ensureCalled(function(event) {
        if (event.type === "focus") {
          return input.blur();
        }
      });
      input.addEventListener("focus", activeListener, false);
      input.addEventListener("click", activeListener, false);
      activateLinkHintsMode();
      hint = getHintMarkers().filter(function(hint) {
        return input === HintCoordinator.getLocalHintMarker(hint.hintDescriptor).element;
      })[0];
      ref = hint.hintString;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        char = ref[k];
        sendKeyboardEvent(char);
      }
      input.removeEventListener("focus", activeListener, false);
      results.push(input.removeEventListener("click", activeListener, false));
    }
    return results;
  }));

  context("Test link hints for changing mode", setup(function() {
    var testDiv;
    initializeModeState();
    testDiv = document.getElementById("test-div");
    testDiv.innerHTML = "<a>link</a>";
    return this.linkHints = activateLinkHintsMode();
  }), tearDown(function() {
    document.getElementById("test-div").innerHTML = "";
    return this.linkHints.deactivateMode();
  }), should("change mode on shift", function() {
    assert.equal("curr-tab", this.linkHints.mode.name);
    sendKeyboardEvent("Shift", "keydown");
    assert.equal("bg-tab", this.linkHints.mode.name);
    sendKeyboardEvent("Shift", "keyup");
    return assert.equal("curr-tab", this.linkHints.mode.name);
  }), should("change mode on ctrl", function() {
    assert.equal("curr-tab", this.linkHints.mode.name);
    sendKeyboardEvent("Control", "keydown");
    assert.equal("fg-tab", this.linkHints.mode.name);
    sendKeyboardEvent("Control", "keyup");
    return assert.equal("curr-tab", this.linkHints.mode.name);
  }));

  context("Alphabetical link hints", setup(function() {
    initializeModeState();
    stubSettings("filterLinkHints", false);
    stubSettings("linkHintCharacters", "ab");
    stub(window, "windowIsFocused", function() {
      return true;
    });
    document.getElementById("test-div").innerHTML = "";
    createLinks(3);
    return this.linkHints = activateLinkHintsMode();
  }), tearDown(function() {
    this.linkHints.deactivateMode();
    return document.getElementById("test-div").innerHTML = "";
  }), should("label the hints correctly", function() {
    var expectedHints, hint, hintMarkers, i, j, len, results;
    hintMarkers = getHintMarkers();
    expectedHints = ["aa", "b", "ab"];
    assert.equal(3, hintMarkers.length);
    results = [];
    for (i = j = 0, len = expectedHints.length; j < len; i = ++j) {
      hint = expectedHints[i];
      results.push(assert.equal(hint, hintMarkers[i].hintString));
    }
    return results;
  }), should("narrow the hints", function() {
    var hintMarkers;
    hintMarkers = getHintMarkers();
    sendKeyboardEvent("a");
    assert.equal("none", hintMarkers[1].style.display);
    return assert.equal("", hintMarkers[0].style.display);
  }), should("generate the correct number of alphabet hints", function() {
    var alphabetHints, hintStrings, j, len, n, ref, results;
    alphabetHints = new AlphabetHints;
    ref = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      n = ref[j];
      hintStrings = alphabetHints.hintStrings(n);
      results.push(assert.equal(n, hintStrings.length));
    }
    return results;
  }), should("generate non-overlapping alphabet hints", function() {
    var alphabetHints, h1, h2, hintStrings, j, len, n, ref, results;
    alphabetHints = new AlphabetHints;
    ref = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      n = ref[j];
      hintStrings = alphabetHints.hintStrings(n);
      results.push((function() {
        var k, len1, results1;
        results1 = [];
        for (k = 0, len1 = hintStrings.length; k < len1; k++) {
          h1 = hintStrings[k];
          results1.push((function() {
            var l, len2, results2;
            results2 = [];
            for (l = 0, len2 = hintStrings.length; l < len2; l++) {
              h2 = hintStrings[l];
              if (h1 !== h2) {
                results2.push(assert.isFalse(0 === h1.indexOf(h2)));
              } else {
                results2.push(void 0);
              }
            }
            return results2;
          })());
        }
        return results1;
      })());
    }
    return results;
  }));

  context("Filtered link hints", setup(function() {
    stubSettings("filterLinkHints", true);
    stubSettings("linkHintNumbers", "0123456789");
    return stub(window, "windowIsFocused", function() {
      return true;
    });
  }), context("Text hints", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<a>test</a>" + "<a>tress</a>" + "<a>trait</a>" + "<a>track<img alt='alt text'/></a>";
    document.getElementById("test-div").innerHTML = testContent;
    return this.linkHints = activateLinkHintsMode();
  }), tearDown(function() {
    document.getElementById("test-div").innerHTML = "";
    return this.linkHints.deactivateMode();
  }), should("label the hints", function() {
    var actualMarkers, expectedMarkers, hintMarkers, j, len, marker, results;
    hintMarkers = getHintMarkers();
    expectedMarkers = [1, 2, 3, 4].map(function(m) {
      return m.toString();
    });
    actualMarkers = [0, 1, 2, 3].map(function(i) {
      return hintMarkers[i].textContent.toLowerCase();
    });
    assert.equal(expectedMarkers.length, actualMarkers.length);
    results = [];
    for (j = 0, len = expectedMarkers.length; j < len; j++) {
      marker = expectedMarkers[j];
      results.push(assert.isTrue(indexOf.call(actualMarkers, marker) >= 0));
    }
    return results;
  }), should("narrow the hints", function() {
    var hintMarkers;
    hintMarkers = getHintMarkers();
    sendKeyboardEvent("t");
    sendKeyboardEvent("r");
    assert.equal("none", hintMarkers[0].style.display);
    assert.equal("3", hintMarkers[1].hintString);
    assert.equal("", hintMarkers[1].style.display);
    sendKeyboardEvent("a");
    return assert.equal("1", hintMarkers[3].hintString);
  }), should("narrow the hints and ignore typing mistakes", function() {
    var hintMarkers;
    hintMarkers = getHintMarkers();
    sendKeyboardEvent("t");
    sendKeyboardEvent("r");
    sendKeyboardEvent("x");
    assert.equal("none", hintMarkers[0].style.display);
    assert.equal("3", hintMarkers[1].hintString);
    assert.equal("", hintMarkers[1].style.display);
    sendKeyboardEvent("a");
    return assert.equal("1", hintMarkers[3].hintString);
  })), context("Image hints", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<a><img alt='alt text'/></a><a><img alt='alt text' title='some title'/></a> <a><img title='some title'/></a>" + "<a><img src='' width='320px' height='100px'/></a>";
    document.getElementById("test-div").innerHTML = testContent;
    return this.linkHints = activateLinkHintsMode();
  }), tearDown(function() {
    document.getElementById("test-div").innerHTML = "";
    return this.linkHints.deactivateMode();
  }), should("label the images", function() {
    var hintMarkers;
    hintMarkers = getHintMarkers().map(function(marker) {
      return marker.textContent.toLowerCase();
    });
    hintMarkers = hintMarkers.map(function(str) {
      return str.replace(/^[1-4]/, "N");
    });
    assert.equal(4, hintMarkers.length);
    assert.isTrue(indexOf.call(hintMarkers, "N: alt text") >= 0);
    assert.isTrue(indexOf.call(hintMarkers, "N: some title") >= 0);
    assert.isTrue(indexOf.call(hintMarkers, "N: alt text") >= 0);
    return assert.isTrue(indexOf.call(hintMarkers, "N") >= 0);
  })), context("Input hints", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<input type='text' value='some value'/><input type='password' value='some value'/> <textarea>some text</textarea><label for='test-input'/>a label</label> <input type='text' id='test-input' value='some value'/> <label for='test-input-2'/>a label: </label><input type='text' id='test-input-2' value='some value'/>";
    document.getElementById("test-div").innerHTML = testContent;
    return this.linkHints = activateLinkHintsMode();
  }), tearDown(function() {
    document.getElementById("test-div").innerHTML = "";
    return this.linkHints.deactivateMode();
  }), should("label the input elements", function() {
    var hintMarkers;
    hintMarkers = getHintMarkers();
    hintMarkers = getHintMarkers().map(function(marker) {
      return marker.textContent.toLowerCase();
    });
    hintMarkers = hintMarkers.map(function(str) {
      return str.replace(/^[0-9]+/, "N");
    });
    assert.equal(5, hintMarkers.length);
    assert.isTrue(indexOf.call(hintMarkers, "N") >= 0);
    assert.isTrue(indexOf.call(hintMarkers, "N") >= 0);
    assert.isTrue(indexOf.call(hintMarkers, "N: a label") >= 0);
    assert.isTrue(indexOf.call(hintMarkers, "N: a label") >= 0);
    return assert.isTrue(indexOf.call(hintMarkers, "N") >= 0);
  })), context("Text hint scoring", setup(function() {
    var testContent;
    initializeModeState();
    testContent = [
      {
        id: 0,
        text: "the xboy stood on the xburning deck"
      }, {
        id: 1,
        text: "the boy stood on the xburning deck"
      }, {
        id: 2,
        text: "on the xboy stood the xburning deck"
      }, {
        id: 3,
        text: "the xboy stood on the xburning deck"
      }, {
        id: 4,
        text: "the xboy stood on the xburning deck"
      }, {
        id: 5,
        text: "the xboy stood on the xburning"
      }, {
        id: 6,
        text: "the xboy stood on the burning xdeck"
      }, {
        id: 7,
        text: "test abc one - longer"
      }, {
        id: 8,
        text: "test abc one"
      }, {
        id: 9,
        text: "test abc one - longer still"
      }
    ].map(function(arg) {
      var id, text;
      id = arg.id, text = arg.text;
      return "<a id=\"" + id + "\">" + text + "</a>";
    }).join(" ");
    document.getElementById("test-div").innerHTML = testContent;
    this.linkHints = activateLinkHintsMode();
    return this.getActiveHintMarker = function() {
      return HintCoordinator.getLocalHintMarker(this.linkHints.markerMatcher.activeHintMarker.hintDescriptor).element.id;
    };
  }), tearDown(function() {
    document.getElementById("test-div").innerHTML = "";
    return this.linkHints.deactivateMode();
  }), should("score start-of-word matches highly", function() {
    sendKeyboardEvents("bu");
    return assert.equal("6", this.getActiveHintMarker());
  }), should("score start-of-text matches highly (br)", function() {
    sendKeyboardEvents("on");
    return assert.equal("2", this.getActiveHintMarker());
  }), should("score whole-word matches highly", function() {
    sendKeyboardEvents("boy");
    return assert.equal("1", this.getActiveHintMarker());
  }), should("score shorter texts more highly", function() {
    sendKeyboardEvents("stood");
    return assert.equal("5", this.getActiveHintMarker());
  }), should("use tab to select the active hint", function() {
    sendKeyboardEvents("abc");
    assert.equal("8", this.getActiveHintMarker());
    sendKeyboardEvent("Tab", "keydown");
    assert.equal("7", this.getActiveHintMarker());
    sendKeyboardEvent("Tab", "keydown");
    return assert.equal("9", this.getActiveHintMarker());
  })));

  context("Input focus", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<input type='text' id='first'/><input style='display:none;' id='second'/> <input type='password' id='third' value='some value'/>";
    return document.getElementById("test-div").innerHTML = testContent;
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("focus the first element", function() {
    focusInput(1);
    return assert.equal("first", document.activeElement.id);
  }), should("focus the nth element", function() {
    focusInput(100);
    return assert.equal("third", document.activeElement.id);
  }), should("activate insert mode on the first element", function() {
    focusInput(1);
    return assert.isTrue(InsertMode.permanentInstance.isActive());
  }), should("activate insert mode on the first element", function() {
    focusInput(100);
    return assert.isTrue(InsertMode.permanentInstance.isActive());
  }), should("activate the most recently-selected input if the count is 1", function() {
    focusInput(3);
    focusInput(1);
    return assert.equal("third", document.activeElement.id);
  }), should("not trigger insert if there are no inputs", function() {
    document.getElementById("test-div").innerHTML = "";
    focusInput(1);
    return assert.isFalse(InsertMode.permanentInstance.isActive());
  }));

  context("Find prev / next links", setup(function() {
    initializeModeState();
    return window.location.hash = "";
  }), should("find exact matches", function() {
    document.getElementById("test-div").innerHTML = "<a href='#first'>nextcorrupted</a>\n<a href='#second'>next page</a>";
    stubSettings("nextPatterns", "next");
    goNext();
    return assert.equal('#second', window.location.hash);
  }), should("match against non-word patterns", function() {
    document.getElementById("test-div").innerHTML = "<a href='#first'>&gt;&gt;</a>";
    stubSettings("nextPatterns", ">>");
    goNext();
    return assert.equal('#first', window.location.hash);
  }), should("favor matches with fewer words", function() {
    document.getElementById("test-div").innerHTML = "<a href='#first'>lorem ipsum next</a>\n<a href='#second'>next!</a>";
    stubSettings("nextPatterns", "next");
    goNext();
    return assert.equal('#second', window.location.hash);
  }), should("find link relation in header", function() {
    document.getElementById("test-div").innerHTML = "<link rel='next' href='#first'>";
    goNext();
    return assert.equal('#first', window.location.hash);
  }), should("favor link relation to text matching", function() {
    document.getElementById("test-div").innerHTML = "<link rel='next' href='#first'>\n<a href='#second'>next</a>";
    goNext();
    return assert.equal('#first', window.location.hash);
  }), should("match mixed case link relation", function() {
    document.getElementById("test-div").innerHTML = "<link rel='Next' href='#first'>";
    goNext();
    return assert.equal('#first', window.location.hash);
  }));

  createLinks = function(n) {
    var i, j, link, ref, results;
    results = [];
    for (i = j = 0, ref = n; j < ref; i = j += 1) {
      link = document.createElement("a");
      link.textContent = "test";
      results.push(document.getElementById("test-div").appendChild(link));
    }
    return results;
  };

  context("Key mapping", setup(function() {
    this.normalMode = initializeModeState();
    this.handlerCalled = false;
    this.handlerCalledCount = 0;
    return this.normalMode.setCommandHandler((function(_this) {
      return function(arg) {
        var count;
        count = arg.count;
        _this.handlerCalled = true;
        return _this.handlerCalledCount = count;
      };
    })(this));
  }), should("recognize first mapped key", function() {
    return assert.isTrue(this.normalMode.isMappedKey("m"));
  }), should("recognize second mapped key", function() {
    assert.isFalse(this.normalMode.isMappedKey("p"));
    sendKeyboardEvent("z");
    return assert.isTrue(this.normalMode.isMappedKey("p"));
  }), should("recognize pass keys", function() {
    return assert.isTrue(this.normalMode.isPassKey("p"));
  }), should("not mis-recognize pass keys", function() {
    assert.isFalse(this.normalMode.isMappedKey("p"));
    sendKeyboardEvent("z");
    return assert.isTrue(this.normalMode.isMappedKey("p"));
  }), should("recognize initial count keys", function() {
    assert.isTrue(this.normalMode.isCountKey("1"));
    return assert.isTrue(this.normalMode.isCountKey("9"));
  }), should("not recognize '0' as initial count key", function() {
    return assert.isFalse(this.normalMode.isCountKey("0"));
  }), should("recognize subsequent count keys", function() {
    sendKeyboardEvent("1");
    assert.isTrue(this.normalMode.isCountKey("0"));
    return assert.isTrue(this.normalMode.isCountKey("9"));
  }), should("set and call command handler", function() {
    sendKeyboardEvent("m");
    return assert.isTrue(this.handlerCalled);
  }), should("not call command handler for pass keys", function() {
    sendKeyboardEvent("p");
    return assert.isFalse(this.handlerCalled);
  }), should("accept a count prefix with a single digit", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("m");
    return assert.equal(2, this.handlerCalledCount);
  }), should("accept a count prefix with multiple digits", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("0");
    sendKeyboardEvent("m");
    return assert.equal(20, this.handlerCalledCount);
  }), should("cancel a count prefix", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("z");
    sendKeyboardEvent("m");
    return assert.equal(1, this.handlerCalledCount);
  }), should("accept a count prefix for multi-key command mappings", function() {
    sendKeyboardEvent("5");
    sendKeyboardEvent("z");
    sendKeyboardEvent("p");
    return assert.equal(5, this.handlerCalledCount);
  }), should("cancel a key prefix", function() {
    sendKeyboardEvent("z");
    sendKeyboardEvent("m");
    return assert.equal(1, this.handlerCalledCount);
  }), should("cancel a count prefix after a prefix key", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("z");
    sendKeyboardEvent("m");
    return assert.equal(1, this.handlerCalledCount);
  }), should("cancel a prefix key on escape", function() {
    sendKeyboardEvent("z");
    sendKeyboardEvent("Escape", "keydown");
    sendKeyboardEvent("p");
    return assert.equal(0, this.handlerCalledCount);
  }));

  context("Normal mode", setup(function() {
    return initializeModeState();
  }), should("invoke commands for mapped keys", function() {
    sendKeyboardEvent("m");
    return assert.equal("m", commandName);
  }), should("invoke commands for mapped keys with a mapped prefix", function() {
    sendKeyboardEvent("z");
    sendKeyboardEvent("m");
    return assert.equal("m", commandName);
  }), should("invoke commands for mapped keys with an unmapped prefix", function() {
    sendKeyboardEvent("a");
    sendKeyboardEvent("m");
    return assert.equal("m", commandName);
  }), should("not invoke commands for pass keys", function() {
    sendKeyboardEvent("p");
    return assert.equal(null, commandName);
  }), should("not invoke commands for pass keys with an unmapped prefix", function() {
    sendKeyboardEvent("a");
    sendKeyboardEvent("p");
    return assert.equal(null, commandName);
  }), should("invoke commands for pass keys with a count", function() {
    sendKeyboardEvent("1");
    sendKeyboardEvent("p");
    return assert.equal("p", commandName);
  }), should("invoke commands for pass keys with a key queue", function() {
    sendKeyboardEvent("z");
    sendKeyboardEvent("p");
    return assert.equal("zp", commandName);
  }), should("default to a count of 1", function() {
    sendKeyboardEvent("m");
    return assert.equal(1, commandCount);
  }), should("accept count prefixes of length 1", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("m");
    return assert.equal(2, commandCount);
  }), should("accept count prefixes of length 2", function() {
    sendKeyboardEvents("12");
    sendKeyboardEvent("m");
    return assert.equal(12, commandCount);
  }), should("get the correct count for mixed inputs (single key)", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("z");
    sendKeyboardEvent("m");
    return assert.equal(1, commandCount);
  }), should("get the correct count for mixed inputs (multi key)", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("z");
    sendKeyboardEvent("p");
    return assert.equal(2, commandCount);
  }), should("get the correct count for mixed inputs (multi key, duplicates)", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("z");
    sendKeyboardEvent("z");
    sendKeyboardEvent("p");
    return assert.equal(1, commandCount);
  }), should("get the correct count for mixed inputs (with leading mapped keys)", function() {
    sendKeyboardEvent("z");
    sendKeyboardEvent("2");
    sendKeyboardEvent("m");
    return assert.equal(2, commandCount);
  }), should("get the correct count for mixed inputs (with leading unmapped keys)", function() {
    sendKeyboardEvent("a");
    sendKeyboardEvent("2");
    sendKeyboardEvent("m");
    return assert.equal(2, commandCount);
  }), should("not get a count after unmapped keys", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("a");
    sendKeyboardEvent("m");
    return assert.equal(1, commandCount);
  }), should("get the correct count after unmapped keys", function() {
    sendKeyboardEvent("2");
    sendKeyboardEvent("a");
    sendKeyboardEvent("3");
    sendKeyboardEvent("m");
    return assert.equal(3, commandCount);
  }), should("not handle unmapped keys", function() {
    sendKeyboardEvent("u");
    return assert.equal(null, commandCount);
  }));

  context("Insert mode", setup(function() {
    initializeModeState();
    return this.insertMode = new InsertMode({
      global: true
    });
  }), should("exit on escape", function() {
    assert.isTrue(this.insertMode.modeIsActive);
    sendKeyboardEvent("Escape", "keydown");
    return assert.isFalse(this.insertMode.modeIsActive);
  }), should("resume normal mode after leaving insert mode", function() {
    assert.equal(null, commandCount);
    this.insertMode.exit();
    sendKeyboardEvent("m");
    return assert.equal(1, commandCount);
  }));

  context("Triggering insert mode", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<input type='text' id='first'/> <input style='display:none;' id='second'/> <input type='password' id='third' value='some value'/> <p id='fourth' contenteditable='true'/> <p id='fifth'/>";
    return document.getElementById("test-div").innerHTML = testContent;
  }), tearDown(function() {
    var ref;
    if ((ref = document.activeElement) != null) {
      ref.blur();
    }
    return document.getElementById("test-div").innerHTML = "";
  }), should("trigger insert mode on focus of text input", function() {
    assert.isFalse(InsertMode.permanentInstance.isActive());
    document.getElementById("first").focus();
    return assert.isTrue(InsertMode.permanentInstance.isActive());
  }), should("trigger insert mode on focus of password input", function() {
    assert.isFalse(InsertMode.permanentInstance.isActive());
    document.getElementById("third").focus();
    return assert.isTrue(InsertMode.permanentInstance.isActive());
  }), should("trigger insert mode on focus of contentEditable elements", function() {
    assert.isFalse(InsertMode.permanentInstance.isActive());
    document.getElementById("fourth").focus();
    return assert.isTrue(InsertMode.permanentInstance.isActive());
  }), should("not trigger insert mode on other elements", function() {
    assert.isFalse(InsertMode.permanentInstance.isActive());
    document.getElementById("fifth").focus();
    return assert.isFalse(InsertMode.permanentInstance.isActive());
  }));

  context("Caret mode", setup(function() {
    document.getElementById("test-div").innerHTML = "<p><pre>\n  It is an ancient Mariner,\n  And he stoppeth one of three.\n  By thy long grey beard and glittering eye,\n  Now wherefore stopp'st thou me?\n</pre></p>";
    initializeModeState();
    return this.initialVisualMode = new VisualMode;
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("enter caret mode", function() {
    assert.isFalse(this.initialVisualMode.modeIsActive);
    return assert.equal("I", getSelection());
  }), should("exit caret mode on escape", function() {
    sendKeyboardEvent("Escape", "keydown");
    return assert.equal("", getSelection());
  }), should("move caret with l and h", function() {
    assert.equal("I", getSelection());
    sendKeyboardEvent("l");
    assert.equal("t", getSelection());
    sendKeyboardEvent("h");
    return assert.equal("I", getSelection());
  }), should("move caret with w and b", function() {
    assert.equal("I", getSelection());
    sendKeyboardEvent("w");
    assert.equal("i", getSelection());
    sendKeyboardEvent("b");
    return assert.equal("I", getSelection());
  }), should("move caret with e", function() {
    assert.equal("I", getSelection());
    sendKeyboardEvent("e");
    assert.equal(" ", getSelection());
    sendKeyboardEvent("e");
    return assert.equal(" ", getSelection());
  }), should("move caret with j and k", function() {
    assert.equal("I", getSelection());
    sendKeyboardEvent("j");
    assert.equal("A", getSelection());
    sendKeyboardEvent("k");
    return assert.equal("I", getSelection());
  }), should("re-use an existing selection", function() {
    assert.equal("I", getSelection());
    sendKeyboardEvents("ww");
    assert.equal("a", getSelection());
    sendKeyboardEvent("Escape", "keydown");
    new VisualMode;
    return assert.equal("a", getSelection());
  }), should("not move the selection on caret/visual mode toggle", function() {
    var j, key, len, ref, results;
    sendKeyboardEvents("ww");
    assert.equal("a", getSelection());
    ref = "vcvcvc".split();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      sendKeyboardEvent(key);
      results.push(assert.equal("a", getSelection()));
    }
    return results;
  }));

  context("Visual mode", setup(function() {
    document.getElementById("test-div").innerHTML = "<p><pre>\n  It is an ancient Mariner,\n  And he stoppeth one of three.\n  By thy long grey beard and glittering eye,\n  Now wherefore stopp'st thou me?\n</pre></p>";
    initializeModeState();
    this.initialVisualMode = new VisualMode;
    sendKeyboardEvent("w");
    sendKeyboardEvent("w");
    return sendKeyboardEvent("v");
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("select word with e", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvent("e");
    assert.equal("an", getSelection());
    sendKeyboardEvent("e");
    return assert.equal("an ancient", getSelection());
  }), should("select opposite end of the selection with o", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvent("e");
    assert.equal("an", getSelection());
    sendKeyboardEvent("e");
    assert.equal("an ancient", getSelection());
    sendKeyboardEvents("ow");
    assert.equal("ancient", getSelection());
    sendKeyboardEvents("oe");
    return assert.equal("ancient Mariner", getSelection());
  }), should("accept a count", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("2e");
    return assert.equal("an ancient", getSelection());
  }), should("select a word", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("aw");
    return assert.equal("an", getSelection());
  }), should("select a word with a count", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("2aw");
    return assert.equal("an ancient", getSelection());
  }), should("select a word with a count", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("2aw");
    return assert.equal("an ancient", getSelection());
  }), should("select to start of line", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("0");
    return assert.equal("It is", getSelection().trim());
  }), should("select to end of line", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("$");
    return assert.equal("an ancient Mariner,", getSelection());
  }), should("re-enter caret mode", function() {
    assert.equal("a", getSelection());
    sendKeyboardEvents("cww");
    return assert.equal("M", getSelection());
  }));

  context("Mode utilities", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<input type='text' id='first'/> <input style='display:none;' id='second'/> <input type='password' id='third' value='some value'/>";
    return document.getElementById("test-div").innerHTML = testContent;
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("not have duplicate singletons", function() {
    var Test, count, j, mode;
    count = 0;
    Test = (function(superClass) {
      extend1(Test, superClass);

      function Test() {
        count += 1;
        Test.__super__.constructor.call(this, {
          singleton: "test"
        });
      }

      Test.prototype.exit = function() {
        count -= 1;
        return Test.__super__.exit.call(this);
      };

      return Test;

    })(Mode);
    assert.isTrue(count === 0);
    for (j = 1; j <= 10; j++) {
      mode = new Test();
      assert.isTrue(count === 1);
    }
    mode.exit();
    return assert.isTrue(count === 0);
  }), should("exit on escape", function() {
    var test;
    test = new Mode({
      exitOnEscape: true
    });
    assert.isTrue(test.modeIsActive);
    sendKeyboardEvent("Escape", "keydown");
    return assert.isFalse(test.modeIsActive);
  }), should("not exit on escape if not enabled", function() {
    var test;
    test = new Mode({
      exitOnEscape: false
    });
    assert.isTrue(test.modeIsActive);
    sendKeyboardEvent("Escape", "keydown");
    return assert.isTrue(test.modeIsActive);
  }), should("exit on blur", function() {
    var element, test;
    element = document.getElementById("first");
    element.focus();
    test = new Mode({
      exitOnBlur: element
    });
    assert.isTrue(test.modeIsActive);
    element.blur();
    return assert.isFalse(test.modeIsActive);
  }), should("not exit on blur if not enabled", function() {
    var element, test;
    element = document.getElementById("first");
    element.focus();
    test = new Mode({
      exitOnBlur: false
    });
    assert.isTrue(test.modeIsActive);
    element.blur();
    return assert.isTrue(test.modeIsActive);
  }));

  context("PostFindMode", setup(function() {
    var testContent;
    initializeModeState();
    testContent = "<input type='text' id='first'/>";
    document.getElementById("test-div").innerHTML = testContent;
    document.getElementById("first").focus();
    return this.postFindMode = new PostFindMode;
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("be a singleton", function() {
    assert.isTrue(this.postFindMode.modeIsActive);
    new PostFindMode;
    return assert.isFalse(this.postFindMode.modeIsActive);
  }), should("suppress unmapped printable keys", function() {
    sendKeyboardEvent("a");
    return assert.equal(null, commandCount);
  }), should("be deactivated on click events", function() {
    handlerStack.bubbleEvent("click", {
      target: document.activeElement
    });
    return assert.isFalse(this.postFindMode.modeIsActive);
  }), should("enter insert mode on immediate escape", function() {
    sendKeyboardEvent("Escape", "keydown");
    assert.equal(null, commandCount);
    return assert.isFalse(this.postFindMode.modeIsActive);
  }), should("not enter insert mode on subsequent escapes", function() {
    sendKeyboardEvent("a");
    sendKeyboardEvent("Escape", "keydown");
    return assert.isTrue(this.postFindMode.modeIsActive);
  }));

  context("WaitForEnter", setup(function() {
    initializeModeState();
    this.isSuccess = null;
    return this.waitForEnter = new WaitForEnter((function(_this) {
      return function(isSuccess) {
        return _this.isSuccess = isSuccess;
      };
    })(this));
  }), should("exit with success on Enter", function() {
    assert.isTrue(this.waitForEnter.modeIsActive);
    assert.isFalse(this.isSuccess != null);
    sendKeyboardEvent("Enter", "keydown");
    assert.isFalse(this.waitForEnter.modeIsActive);
    return assert.isTrue((this.isSuccess != null) && this.isSuccess === true);
  }), should("exit without success on Escape", function() {
    assert.isTrue(this.waitForEnter.modeIsActive);
    assert.isFalse(this.isSuccess != null);
    sendKeyboardEvent("Escape", "keydown");
    assert.isFalse(this.waitForEnter.modeIsActive);
    return assert.isTrue((this.isSuccess != null) && this.isSuccess === false);
  }), should("not exit on other keyboard events", function() {
    assert.isTrue(this.waitForEnter.modeIsActive);
    assert.isFalse(this.isSuccess != null);
    sendKeyboardEvents("abc");
    assert.isTrue(this.waitForEnter.modeIsActive);
    return assert.isFalse(this.isSuccess != null);
  }));

  context("GrabBackFocus", setup(function() {
    var testContent;
    testContent = "<input type='text' value='some value' id='input'/>";
    document.getElementById("test-div").innerHTML = testContent;
    return stubSettings("grabBackFocus", true);
  }), tearDown(function() {
    return document.getElementById("test-div").innerHTML = "";
  }), should("blur an already focused input", function() {
    document.getElementById("input").focus();
    assert.isTrue(document.activeElement);
    assert.isTrue(DomUtils.isEditable(document.activeElement));
    initializeModeState();
    assert.isTrue(document.activeElement);
    return assert.isFalse(DomUtils.isEditable(document.activeElement));
  }), should("blur a newly focused input", function() {
    initializeModeState();
    document.getElementById("input").focus();
    assert.isTrue(document.activeElement);
    return assert.isFalse(DomUtils.isEditable(document.activeElement));
  }), should("exit on a key event", function() {
    initializeModeState();
    sendKeyboardEvent("a");
    document.getElementById("input").focus();
    assert.isTrue(document.activeElement);
    return assert.isTrue(DomUtils.isEditable(document.activeElement));
  }), should("exit on a mousedown event", function() {
    initializeModeState();
    handlerStack.bubbleEvent("mousedown", {
      target: document.body
    });
    document.getElementById("input").focus();
    assert.isTrue(document.activeElement);
    return assert.isTrue(DomUtils.isEditable(document.activeElement));
  }));

}).call(this);
